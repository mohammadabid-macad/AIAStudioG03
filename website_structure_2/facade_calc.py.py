# -*- coding: utf-8 -*-
"""Facade_Calc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12mWkd3O-gp8YtWFSxYLadNii66BTwYe7

# Part A

## Cell A0: Install Required Libraries
"""

!pip install requests Pillow torch transformers matplotlib numpy tensorflow

"""## Cell A1: Import Libraries and Define Functions"""

import requests
from PIL import Image
import torch
from transformers import DPTFeatureExtractor, DPTForSemanticSegmentation
import matplotlib.pyplot as plt
import numpy as np
from io import BytesIO
import tensorflow as tf
from collections import defaultdict
import joblib

# Function to download and preprocess the image
def download_image(url):
    response = requests.get(url)
    img = Image.open(BytesIO(response.content)).convert("RGB")
    return img

# Function to calculate class percentages
def calculate_class_percentages(predicted_labels, classes):
    total_pixels = predicted_labels.size
    percentages = {class_id: np.sum(predicted_labels == class_id) / total_pixels * 100 for class_id in classes.keys()}
    return percentages

# Function to preprocess patches from the building segment for the material classifier
def extract_patches(building_image, patch_size=128, stride=64):
    building_array = np.array(building_image)
    h, w, _ = building_array.shape
    patches = []
    for i in range(0, h - patch_size + 1, stride):
        for j in range(0, w - patch_size + 1, stride):
            patch = building_array[i:i+patch_size, j:j+patch_size]
            if np.sum(patch) > 0:  # Avoid patches with only background
                patches.append(patch)
    patches = np.array(patches) / 255.0
    return patches

# Load segmentation model and feature extractor
feature_extractor = DPTFeatureExtractor.from_pretrained("Intel/dpt-large-ade")
segmentation_model = DPTForSemanticSegmentation.from_pretrained("Intel/dpt-large-ade")

# Load your material texture classifier model
classifier_model_url = "https://github.com/mohammadabid-macad/AIAStudioG03/raw/65f48a58e1f1ea1c8ac387facfa78a6ba20b467d/models/material_texture_classifier.keras"
response = requests.get(classifier_model_url)
classifier_model_path = 'material_texture_classifier.keras'
with open(classifier_model_path, 'wb') as file:
    file.write(response.content)
classifier_model = tf.keras.models.load_model(classifier_model_path)

"""## Cell A2: Segment Image and Extract Material Percentages"""

# URL of the image to be segmented
image_url = "https://github.com/mohammadabid-macad/AIAStudioG03/raw/65f48a58e1f1ea1c8ac387facfa78a6ba20b467d/images/building_('way'%2C%201032480044)_heading_86.08660942757444.jpg"

# Download and preprocess the image
original_image = download_image(image_url)
inputs = feature_extractor(images=original_image, return_tensors="pt")

# Perform segmentation
with torch.no_grad():
    outputs = segmentation_model(**inputs)
    logits = outputs.logits
    upsampled_logits = torch.nn.functional.interpolate(logits, size=original_image.size[::-1], mode="bilinear", align_corners=False)
    predicted_labels = upsampled_logits.argmax(dim=1).squeeze().numpy()

# Define the class mappings
foliage_classes = [8, 10, 12, 17, 18, 19, 20]  # Example foliage classes, adjust as necessary
building_class = 1
sky_class = 22

# Create a new map for the desired classes
new_predicted_labels = np.zeros_like(predicted_labels)
new_predicted_labels[np.isin(predicted_labels, foliage_classes)] = 1  # Foliage
new_predicted_labels[predicted_labels == building_class] = 2  # Building
new_predicted_labels[predicted_labels == sky_class] = 3  # Sky

# Define the colors and names for each class
classes = {
    0: {"name": "Background", "color": [0, 0, 0]},
    1: {"name": "Foliage", "color": [107, 142, 35]},
    2: {"name": "Building", "color": [128, 64, 128]},
    3: {"name": "Sky", "color": [135, 206, 235]}
}

# Calculate percentage for each class
percentages = calculate_class_percentages(new_predicted_labels, classes)

# Print the percentages with class names
for class_id, percentage in percentages.items():
    print(f"{classes[class_id]['name']}: {percentage:.2f}%")

# Visualize the segmentation
colored_segmentation = np.zeros((new_predicted_labels.shape[0], new_predicted_labels.shape[1], 3), dtype=np.uint8)
for class_id, class_info in classes.items():
    colored_segmentation[new_predicted_labels == class_id] = class_info["color"]

plt.figure(figsize=(10, 10))
plt.imshow(original_image)
plt.imshow(colored_segmentation, alpha=0.6)
plt.axis('off')
plt.show()

"""## Cell A3: Extract Building Segment and Classify Materials"""

# Extract the building segment
building_mask = (new_predicted_labels == 2)
building_segment = np.array(original_image) * np.repeat(building_mask[:, :, np.newaxis], 3, axis=2)

# Convert the building segment back to an image
building_image = Image.fromarray(building_segment.astype('uint8'))

# Visualize the building segment
plt.figure(figsize=(10, 10))
plt.imshow(building_image)
plt.axis('off')
plt.show()

# Extract patches
patches = extract_patches(building_image)

# Debugging: Print the shape of the patches
print(f"Patches shape: {patches.shape}")

# Classify each patch
material_predictions = classifier_model.predict(patches)

# Debugging: Print the shape of the predictions
print(f"Material predictions shape: {material_predictions.shape}")

material_classes = ['brick', 'ceramic', 'glass', 'metal', 'paint', 'stone', 'tile', 'wood']
material_counts = {material: 0 for material in material_classes}

for pred in material_predictions:
    argmax_index = np.argmax(pred)
    # Debugging: Print the argmax index and the corresponding prediction
    print(f"Argmax index: {argmax_index}, Prediction: {pred}")
    if argmax_index < len(material_classes):
        material_class = material_classes[argmax_index]
        material_counts[material_class] += 1

# Calculate percentages for each material in the building segment
total_building_patches = len(patches)
material_percentages = {material: (count / total_building_patches) * 100 for material, count in material_counts.items()}

# Print the material classification results with percentages
for material, percentage in material_percentages.items():
    print(f"{material}: {percentage:.2f}%")

"""# Part B

## 00: Install Dependencies
"""

!pip install osmnx geopandas shapely pandas pyproj requests tensorflow

import osmnx as ox
import geopandas as gpd
from shapely.geometry import Point, LineString
import pandas as pd
import pyproj
import requests
import tensorflow as tf

"""## 01: Define Sample Data"""

# Sample values for material percentages
brick_percentage = 0.45779499411582947
ceramic_percentage = 0.058589570224285126
glass_percentage = 0.03563307225704193
metal_percentage = 0.000011294204341538716
painted_percentage = 0.015030953101813793
tile_percentage = 0.07241785526275635
wood_percentage = 0.20852695405483246

# Given latitude and longitude values from the sample data
lat, lon = 51.52748,-0.16664

# Print sample data
print(f"Sample data: lat={lat}, lon={lon}, brick_percentage={brick_percentage}")

"""## 02: Load OSMnx Graph and Buildings"""

# Create a bounding box around the given coordinates
distance = 1000  # distance in meters for the bounding box
bbox = ox.utils_geo.bbox_from_point(point=(lat, lon), dist=distance)

# Load the OSMnx graph for the bounding box
G = ox.graph_from_bbox(bbox[0], bbox[1], bbox[2], bbox[3], network_type='all')
buildings = ox.geometries_from_bbox(bbox[0], bbox[1], bbox[2], bbox[3], tags={'building': True})

# Calculate the distance from the given point to all building centroids and find the closest building
buildings['centroid'] = buildings.centroid
given_point = Point(lon, lat)
buildings['distance'] = buildings['centroid'].apply(lambda x: x.distance(given_point))
closest_building = buildings.loc[buildings['distance'].idxmin()]

# Retrieve the corresponding building polygon
building_polygon = closest_building['geometry']

# Print closest building information
osm_id = closest_building.name  # OSM ID is usually stored in the index
building_name = closest_building.get('name', 'N/A')  # Attempt to get the building name if available
print(f"Closest building OSM ID: {osm_id}")
print(f"Closest building name: {building_name}")
print(f"Closest building centroid: {closest_building['centroid']}, Distance: {closest_building['distance']}")

"""## 03: Convert CRS and Explode Building Polygons"""

# Define the CRS (Coordinate Reference System) based on the given latitude and longitude
utm_crs = ox.projection.project_gdf(gpd.GeoDataFrame(geometry=[Point(lon, lat)], crs='EPSG:4326')).crs

# Convert the closest building and street network to the UTM CRS
closest_building_gdf = gpd.GeoDataFrame([closest_building], crs=buildings.crs).set_geometry('geometry')
closest_building_gdf = closest_building_gdf.to_crs(utm_crs)
street_edges = ox.graph_to_gdfs(G, nodes=False).to_crs(utm_crs)

# Function to explode the building polygon into edges
def extract_edges(polygon):
    if polygon.geom_type == 'Polygon':
        return [LineString([polygon.exterior.coords[i], polygon.exterior.coords[i+1]]) for i in range(len(polygon.exterior.coords)-1)]
    return []

# Extract edges for the closest building
closest_building_edges = extract_edges(closest_building_gdf.geometry.iloc[0])

# Buffer the street edges
buffered_street_edges = street_edges.buffer(10)

# Function to calculate street-facing edge lengths
def calculate_street_facing_edges(edges, buffer_gdf):
    street_facing_edges = [edge for edge in edges if buffer_gdf.intersects(edge).any()]
    return street_facing_edges

# Calculate street-facing edges
street_facing_edges = calculate_street_facing_edges(closest_building_edges, buffered_street_edges)

# Print CRS and edge information
print(f"UTM CRS: {utm_crs}")
print(f"Total number of building edges: {len(closest_building_edges)}")
print(f"Number of street-facing edges: {len(street_facing_edges)}")

"""## 04: Load Trained Model"""

import joblib
import requests

# Define the new model and scaler URLs
model_url = "https://github.com/mohammadabid-macad/AIAStudioG03/raw/65f48a58e1f1ea1c8ac387facfa78a6ba20b467d/models/studio_trained_controlled.keras"
scaler_url = "https://github.com/mohammadabid-macad/AIAStudioG03/raw/65f48a58e1f1ea1c8ac387facfa78a6ba20b467d/models/Sscaler_nooutlier.pkl"

# Download the new model
response = requests.get(model_url)
model_path = 'studio_trained_controlled.keras'
with open(model_path, 'wb') as file:
    file.write(response.content)

# Download the scaler
response = requests.get(scaler_url)
scaler_path = 'Sscaler_nooutlier.pkl'
with open(scaler_path, 'wb') as file:
    file.write(response.content)

# Load the new model
model = tf.keras.models.load_model(model_path)

# Load the scaler
scaler = joblib.load(scaler_path)

# Print model summary to verify loading
model.summary()

# Print scaler information to verify loading
print("Scaler loaded successfully")

"""## 05: Map Building Categories"""

# Mapping dictionary for building categories
building_type_mapping = {
    'house': 'residential',
    'apartments': 'residential',
    'residential': 'residential',
    'semidetached_house': 'residential',
    'terrace': 'residential',
    'dormitory': 'residential',
    'retail': 'retail',
    'commercial': 'commercial',
    'detached': 'residential',
    'garages': 'other',
    'office': 'office',
    'university': 'education',
    'school': 'education',
    'garage': 'other',
    'roof': 'other',
    'church': 'religious',
    'shed': 'other',
    'service': 'other',
    'industrial': 'industrial',
    'train_station': 'transport',
    'hotel': 'hospitality',
    'pub': 'hospitality',
    'air_shaft': 'other',
    'warehouse': 'industrial',
    'hospital': 'healthcare',
    'construction': 'other',
    'public': 'institution',
    'bridge': 'transport',
    'college': 'education',
    'kiosk': 'commercial',
    'civic': 'institution',
    'block': 'other',
    'no': 'other',
    'healthcare': 'healthcare',
    'bunker': 'other',
    'toilets': 'public',
    'hall_of_residence': 'education',
    'restaurant': 'hospitality',
    'kindergarten': 'education',
    'greenhouse': 'other',
    'conservatory': 'other',
    'tower': 'other',
    'hut': 'other',
    'museum': 'institution',
    'presbytery': 'religious',
    'outbuilding': 'other',
    'chapel': 'religious',
    'silo': 'industrial',
    'cafe': 'hospitality',
    'sports_centre': 'sports',
    'multiple': 'other',
    'air_vent': 'other',
    'commerical': 'commercial',
    'container': 'other',
    'student_residence': 'education',
    'shelter': 'public',
    'ruins': 'other',
    'substation': 'other',
    'transportation': 'transport',
    'balcony': 'other',
    'council_flats': 'residential',
    'disused_station': 'transport',
    'portacabins': 'other',
    'cinema': 'hospitality',
    'boathouse': 'other',
    'artists_studio': 'institution',
    'chimney': 'other',
    'vent_shaft': 'other',
    'library': 'institution',
    'gatehouse': 'institution',
    'sports_hall': 'sports',
    'convent': 'religious',
}

# Apply the mapping to categorize the closest building type
closest_building_category = building_type_mapping.get(closest_building['building'], 'other')
closest_building_gdf['building_category'] = closest_building_category

# Print building category
print(f"Closest building category: {closest_building_category}")

"""## 06: Predict Building Height"""

# Function to prepare features and predict building height
def predict_building_height(building):
    features = pd.DataFrame({
        "Building_FootprintArea": [building['geometry'].area],
        "Category_commercial": [1 if building.get('building_category') == 'commercial' else 0],
        "Category_education": [1 if building.get('building_category') == 'education' else 0],
        "Category_hospitality": [1 if building.get('building_category') == 'hospitality' else 0],
        "Category_industrial": [1 if building.get('building_category') == 'industrial' else 0],
        "Category_office": [1 if building.get('building_category') == 'office' else 0],
        "Category_residential": [1 if building.get('building_category') == 'residential' else 0],
        "Category_retail": [1 if building.get('building_category') == 'retail' else 0],
        "Category_nan": [0],  # Placeholder for missing category
        "latitude": [building['centroid'].y],
        "longitude": [building['centroid'].x],
        "brick": [brick_percentage],
        "ceramic": [ceramic_percentage],
        "glass": [glass_percentage],
        "metal": [metal_percentage],
        "painted": [painted_percentage],
        "tile": [tile_percentage],
        "wood": [wood_percentage]
    })

    # Debug print to check the features DataFrame
    print("Features DataFrame before scaling:")
    print(features)

    # Scale the features
    scaled_features = scaler.transform(features)

    # Debug print to check the scaled features
    print("Scaled Features DataFrame:")
    print(scaled_features)

    # Predict the height using the loaded model
    height_prediction = model.predict(scaled_features)

    # Debug print to check the predicted height
    print(f"Predicted building height: {height_prediction[0][0]}")

    return height_prediction[0][0]

"""## 07: Calculate Facade Area"""

# Function to calculate street-facing edge lengths
def calculate_street_facing_length(edges, buffer_gdf):
    total_length = 0
    for edge in edges:
        if buffer_gdf.intersects(edge).any():
            total_length += edge.length
    return total_length

# Function to calculate facade area
def calculate_facade_area(building, edges, buffer_gdf):
    if pd.notnull(building['building:levels']):
        building_levels = float(building['building:levels'])
        height_source = 'OSM'
    else:
        # Predict the building height if levels data is not available
        building_height = float(predict_building_height(building))
        building_levels = building_height / 3  # Assuming floor-to-floor height is 3 meters
        height_source = 'Prediction Model'

    floor_to_floor_height = 3.0  # meters
    building_height = building_levels * floor_to_floor_height
    facade_edge_length = float(calculate_street_facing_length(edges, buffer_gdf))
    facade_area = building_height * facade_edge_length

    print(f"Facade area: {facade_area}, Building height: {building_height}, Height source: {height_source}")
    return facade_area, building_height, height_source

# Calculate facade area for the closest building
closest_building_facade_area, closest_building_height, closest_building_height_source = calculate_facade_area(closest_building_gdf.iloc[0], street_facing_edges, buffered_street_edges)

"""## 08: Iterate Through Buildings and Calculate Facade Areas"""

# Extract edges for the single building
building_edges = extract_edges(closest_building['geometry'])

# Print to debug
print("Extracted edges for the building:", building_edges)

# Store the calculated results from Cell 07 in the closest_building GeoDataFrame
closest_building_gdf['facade_area'] = closest_building_facade_area
closest_building_gdf['building_height'] = closest_building_height
closest_building_gdf['height_source'] = closest_building_height_source

# Print the closest building information for debugging
print("Closest building information:")
print(closest_building_gdf[['facade_area', 'building_height', 'height_source']])

"""## 09: Calculate Material Areas"""

# Calculate material areas for the closest building
brick_area = closest_building_facade_area * brick_percentage
ceramic_area = closest_building_facade_area * ceramic_percentage
glass_area = closest_building_facade_area * glass_percentage
metal_area = closest_building_facade_area * metal_percentage
painted_area = closest_building_facade_area * painted_percentage
#stone_area = closest_building_facade_area * stone_percentage
tile_area = closest_building_facade_area * tile_percentage
wood_area = closest_building_facade_area * wood_percentage

"""## 10: Display Building Information"""

# Calculate material areas for the closest building
brick_area = closest_building_facade_area * brick_percentage
ceramic_area = closest_building_facade_area * ceramic_percentage
glass_area = closest_building_facade_area * glass_percentage
metal_area = closest_building_facade_area * metal_percentage
painted_area = closest_building_facade_area * painted_percentage
tile_area = closest_building_facade_area * tile_percentage
wood_area = closest_building_facade_area * wood_percentage

# Display the closest building information
print("Closest building information:")
print(f"Latitude: {closest_building['centroid'].y}")
print(f"Longitude: {closest_building['centroid'].x}")
print(f"OSM ID: {closest_building.name}")
print(f"Building Name: {closest_building['name']}")
print(f"Building Category: {closest_building_category}")
print(f"Building Footprint Area: {closest_building['geometry'].area} square meters")
print(f"Total Building Facade Area: {closest_building_facade_area} square meters")
print(f"Brick Area: {brick_area} square meters")
print(f"Ceramic Area: {ceramic_area} square meters")
print(f"Glass Area: {glass_area} square meters")
print(f"Metal Area: {metal_area} square meters")
print(f"Painted Area: {painted_area} square meters")
print(f"Tile Area: {tile_area} square meters")
print(f"Wood Area: {wood_area} square meters")
print(f"Building Height: {closest_building_height} meters")
print(f"Building Height Source: {closest_building_height_source}")